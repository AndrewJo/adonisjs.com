<div id="preamble">
<div class="sectionbody">
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_basic_example">Basic Example</a></li>
<li><a href="#_types_of_relationships">Types Of Relationships</a></li>
<li><a href="#_querying_relationships">Querying Relationships</a></li>
<li><a href="#_filtering_records">Filtering Records</a></li>
<li><a href="#_insert_updates_deletes">Insert, Updates &amp; Deletes</a></li>
</ul>
</div>
<div class="paragraph">
<p>Relational Databases are very powerful in managing the relationship between multiple database tables. Lucid extends this power by offering Javascript-only database associations, which means that you can define a relationship between two tables without touching the SQL schema.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_basic_example"><a class="anchor" href="#_basic_example"></a><a class="link" href="#_basic_example">Basic Example</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Relational databases are intended to define relations between two or more database tables. There are several benefits of defining relationships as they make common database operations a lot easier.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take the most common scenario of a User and a Profile model. Where every user in your database can have a social profile. We call this a <strong>one to one relationship</strong>.</p>
</div>
<div class="paragraph">
<p>To describe this relationship, you will have to add following line of code to your User model.</p>
</div>
<div class="listingblock">
<div class="title">app/Model/User.js</div>
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">'use strict'

const Lucid = use('Lucid')

class User extends Lucid {

  profile () {
    return this.hasOne('App/Model/Profile') <i class="conum" data-value="1"></i><b>(1)</b>
  }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>hasOne</code> method defines a one to one relationship on a given model.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now you can call the <code>profile</code> method to access the profile for a given user.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const user = yield User.find(1)
const userProfile = yield user.profile().fetch()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_types_of_relationships"><a class="anchor" href="#_types_of_relationships"></a><a class="link" href="#_types_of_relationships">Types Of Relationships</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_has_one_relationship"><a class="anchor" href="#_has_one_relationship"></a><a class="link" href="#_has_one_relationship">Has One Relationship</a></h3>
<div class="paragraph">
<p>The <code>hasOne</code> relationship defines a one to one relation between 2 models using a foreign key. Foreign Key is created using the singular name of a given model followed by <strong>_id</strong>. However, you are free to override it.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Model</th>
<th class="tableblock halign-left valign-top">Foreign Key</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">User</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">user_id</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Seller</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">seller_id</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><span class="image"><img src="http://res.cloudinary.com/adonisjs/image/upload/v1472841270/has-one_zfrkve.jpg" alt="has one zfrkve"></span></p>
</div>
<div class="paragraph">
<p>To setup the relationship shown in the above figure, you need to define it inside your User model.</p>
</div>
<div class="sect3">
<h4 id="_hasone_relatedmodel_primarykey_id_foreignkey_user_id"><a class="anchor" href="#_hasone_relatedmodel_primarykey_id_foreignkey_user_id"></a><a class="link" href="#_hasone_relatedmodel_primarykey_id_foreignkey_user_id">hasOne(relatedModel, [primaryKey=id], [foreignKey=user_id])</a></h4>
<div class="listingblock">
<div class="title">app/Model/User.js</div>
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">class User extends Lucid {

  profile () {
    return this.hasOne('App/Model/Profile')
  }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_belongsto_relationship"><a class="anchor" href="#_belongsto_relationship"></a><a class="link" href="#_belongsto_relationship">BelongsTo Relationship</a></h3>
<div class="paragraph">
<p>The <code>belongsTo</code> relationship is the opposite of <code>hasOne</code> and always holds the <strong>foreign key</strong>. So the best way to remember it is with the foreign key. Any database table that has the foreign key, it&#8217;s Model will always have the <code>belongsTo</code> relation.</p>
</div>
<div class="paragraph">
<p>There are no hard rules on how to design your relationships, but it is always nice to design them in the most natural way. For example</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Model</th>
<th class="tableblock halign-left valign-top">Relation</th>
<th class="tableblock halign-left valign-top">Related Model</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">User</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hasOne</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Profile</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Profile</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">belongsTo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">User</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Student</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hasOne</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IdCard</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IdCard</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">belongsTo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">User</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Hope this makes sense. Continuing with our <strong>User</strong> <strong>Profile</strong> relationship, the Profile model will contain the <code>belongsTo</code> relation as it holds the foreign key.</p>
</div>
<div class="sect3">
<h4 id="_belongsto_relatedmodel_primarykey_id_foreignkey_user_id"><a class="anchor" href="#_belongsto_relatedmodel_primarykey_id_foreignkey_user_id"></a><a class="link" href="#_belongsto_relatedmodel_primarykey_id_foreignkey_user_id">belongsTo(relatedModel, [primaryKey=id], [foreignKey=user_id])</a></h4>
<div class="listingblock">
<div class="title">app/Model/Profile.js</div>
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">class Profile extends Lucid {

  user () {
    return this.belongsTo('App/Model/User')
  }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hasmany_relationship"><a class="anchor" href="#_hasmany_relationship"></a><a class="link" href="#_hasmany_relationship">HasMany Relationship</a></h3>
<div class="paragraph">
<p>You will find yourself using <code>hasMany</code> quite often, as this is the most common relationship required by any application. Let&#8217;s review some examples.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Model</th>
<th class="tableblock halign-left valign-top">Relation</th>
<th class="tableblock halign-left valign-top">Related Model</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Book</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hasMany</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Chapter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Chapter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">belongsTo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Book</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Post</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hasMany</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comment</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comment</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">belongsTo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Post</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <code>hasMany</code> relationship makes it possible to have multiple related records for a given row each holding the foreignKey.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="http://res.cloudinary.com/adonisjs/image/upload/v1472841272/has-many_p91i9i.jpg" alt="has many p91i9i"></span></p>
</div>
<div class="paragraph">
<p>Let&#8217;s define the above Models and their relationships in Lucid.</p>
</div>
<div class="sect3">
<h4 id="_hasmany_relatedmodel_primarykey_id_foreignkey_book_id"><a class="anchor" href="#_hasmany_relatedmodel_primarykey_id_foreignkey_book_id"></a><a class="link" href="#_hasmany_relatedmodel_primarykey_id_foreignkey_book_id">hasMany(relatedModel, [primaryKey=id], [foreignKey=book_id])</a></h4>
<div class="listingblock">
<div class="title">app/Model/Book.js</div>
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">class Book extends Lucid {

  chapters () {
    return this.hasMany('App/Model/Chapter')
  }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">app/Model/Chapter.js</div>
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">class Chapter extends Lucid {

  book () {
    return this.belongsTo('App/Model/Book')
  }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_belongstomany_relationship"><a class="anchor" href="#_belongstomany_relationship"></a><a class="link" href="#_belongstomany_relationship">BelongsToMany Relationship</a></h3>
<div class="paragraph">
<p>There are situations where each side of the relationship can have many related rows inside the database. Let&#8217;s see some examples.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Model</th>
<th class="tableblock halign-left valign-top">Relation</th>
<th class="tableblock halign-left valign-top">Related Model</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Student</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">belongsToMany</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Courses</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Course</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">belongsToMany</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Students</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Post</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">belongsToMany</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Categories</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Category</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">belongsToMany</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Posts</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Taking the example of Student and Course, where both models can have many related rows in the database. In other words, it is a <strong>many to many relationship</strong>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="http://res.cloudinary.com/adonisjs/image/upload/v1472841273/belongsto-many_ymawpb.jpg" alt="belongsto many ymawpb"></span></p>
</div>
<div class="paragraph">
<p>Looking at the above figure, you will notice there is a 3rd table called <code>course_student</code>. Since each model on both the ends has many relationships, they cannot hold the foreign key.</p>
</div>
<div class="paragraph">
<p>The third table is known as a <strong>pivot table</strong>.  It holds the Foreign Key for both Models and defines a unique relationship between them. Let&#8217;s define this relationship in Lucid and review configurable options.</p>
</div>
<div class="sect3">
<h4 id="_belongstomany_relatedmodel_pivottable_localkey_otherkey"><a class="anchor" href="#_belongstomany_relatedmodel_pivottable_localkey_otherkey"></a><a class="link" href="#_belongstomany_relatedmodel_pivottable_localkey_otherkey">belongsToMany(relatedModel, [pivotTable], [localKey], [otherKey])</a></h4>
<div class="listingblock">
<div class="title">app/Model/Student.js</div>
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">class Student extends Lucid {

  courses () {
    return this.belongsToMany('App/Model/Course')
  }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">app/Model/Course.js</div>
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">class Course extends Lucid {

  students () {
    return this.belongsToMany('App/Model/Student')
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>belongsToMany</code> method accepts multiple arguments to configure the table/fields for the relationship.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter</th>
<th class="tableblock halign-left valign-top">Required</th>
<th class="tableblock halign-left valign-top">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pivotTable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pivot table is the singular form of each model name, order by name. For example Course and Student model will have <strong>course_student</strong> as the pivot table name.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">localKey</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reference to the model foreign key inside the pivot table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">otherKey</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reference to the related model foreign key inside the pivot table.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_withtimestamps"><a class="anchor" href="#_withtimestamps"></a><a class="link" href="#_withtimestamps">withTimestamps</a></h4>
<div class="paragraph">
<p>Also you choose to save timestamps on the pivot table.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">class Student extends Lucid {
  courses () {
    this.belongsToMany('App/Model/Course').withTimestamps()
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hasmanythrough_relationship"><a class="anchor" href="#_hasmanythrough_relationship"></a><a class="link" href="#_hasmanythrough_relationship">HasManyThrough Relationship</a></h3>
<div class="paragraph">
<p>Another important relation type supported by Lucid is <code>hasManyThrough</code>. Where a given model is dependent on another model via 3rd model</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="http://res.cloudinary.com/adonisjs/image/upload/v1472841274/has-many-through_vux5jm.jpg" alt="has many through vux5jm"></span></p>
</div>
<div class="paragraph">
<p>Taking the example of fetching <strong>posts</strong> for a given <strong>country</strong> is not possible since there is no direct relationship between countries and posts. But with the help of User model, we can set up an indirect relationship between countries and posts and that is called <code>hasManyThrough</code> relationship.</p>
</div>
<div class="listingblock">
<div class="title">app/Model/Country.js</div>
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">class Country extends Lucid {

  posts () {
    return this.hasManyThrough('App/Model/Post', 'App/Model/User')
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now to fetch posts for a given country, you need to call the <code>posts</code> method on the <strong>Country model</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const country = yield Country.findBy('name', 'India')
const posts = yield country.posts().fetch()
response.json(posts)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>hasManyThrough</code> method accepts given options.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter</th>
<th class="tableblock halign-left valign-top">Required</th>
<th class="tableblock halign-left valign-top">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">relatedModel</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">null</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">throughModel</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">null</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">primaryKey</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Model primary key</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">foreignKey</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Model foreign key</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">throughPrimaryKey</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Related model primary key</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">throughForeignKey</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Related model foreign key</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_querying_relationships"><a class="anchor" href="#_querying_relationships"></a><a class="link" href="#_querying_relationships">Querying Relationships</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Querying database for relationships is so straightforward and intuitive with Lucid. You just have to call defined relationship methods without worrying about the <strong>join</strong> queries.</p>
</div>
<div class="paragraph">
<p>Also querying relations is divided into three broad categories of <strong>Lazy Loading</strong>, <strong>Eager Loading</strong> and <strong>Lazy Eager Loading</strong>.</p>
</div>
<div class="sect2">
<h3 id="_lazy_loading"><a class="anchor" href="#_lazy_loading"></a><a class="link" href="#_lazy_loading">Lazy Loading</a></h3>
<div class="paragraph">
<p>Lazy loading is a process of loading relationships after fetching the primary/parent record from the database</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">class User extends Lucid {

  profile () {
    return this.hasOne('App/Model/Profile')
  }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const user = yield User.find(1) <i class="conum" data-value="1"></i><b>(1)</b>
const profile = yield user.profile().fetch() <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First we <code>find</code> a user with the primary key.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Then we call the previously defined <code>profile</code> method to fetch the related profile for the given user.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_defining_query_constraints"><a class="anchor" href="#_defining_query_constraints"></a><a class="link" href="#_defining_query_constraints">Defining Query Constraints</a></h4>
<div class="paragraph">
<p>You can also attach query builder methods to your relationship definitions, and Lucid will make sure to execute them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">class User extends Lucid {

  profile () {
    return this
      .hasOne('App/Model/Profile')
      .where('is_active', true) <i class="conum" data-value="1"></i><b>(1)</b>
  }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Now when you will fetch the related profile for a given user, it will only include the record where is_active=true.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_runtime_query_constraints"><a class="anchor" href="#_runtime_query_constraints"></a><a class="link" href="#_runtime_query_constraints">Runtime Query Constraints</a></h4>
<div class="paragraph">
<p>You can also define runtime query constraints, just by chaining the query builder methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const user = yield User.find(1)
const profile = user
  .profile()
  .where('is_active', true)
  .fetch()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_eager_loading"><a class="anchor" href="#_eager_loading"></a><a class="link" href="#_eager_loading">Eager Loading</a></h3>
<div class="paragraph">
<p>Lazy loading may create <strong>N+1</strong> problem in certain scenarios. For example Loading profile for ten users, one by one will make a total of <strong>11</strong> queries. To eliminate this behavior you can preload/eager load profiles which will result in a total of <strong>2</strong> database queries.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const users = yield User
  .query()
  .with('profile') <i class="conum" data-value="1"></i><b>(1)</b>
  .fetch()

console.log(users.toJSON())</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">[
  {
    id: 1,
    username: 'joe',
    email: '...',
    profile: {
      id: 4,
      avatar: '...'
    }
  }
]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>with</code> method can be used to eager load relationships with the parent record. Also, you can load multiple/nested relationships using the <code>with</code> method.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_eager_loading_multiple_relations"><a class="anchor" href="#_eager_loading_multiple_relations"></a><a class="link" href="#_eager_loading_multiple_relations">Eager Loading Multiple Relations</a></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const users = yield User
  .query()
  .with('profile', 'friends')
  .fetch()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_eager_loading_nested_relations"><a class="anchor" href="#_eager_loading_nested_relations"></a><a class="link" href="#_eager_loading_nested_relations">Eager Loading Nested Relations</a></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const user = yield User
  .query()
  .with('friends.profile')
  .fetch()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_runtime_query_constraints_2"><a class="anchor" href="#_runtime_query_constraints_2"></a><a class="link" href="#_runtime_query_constraints_2">Runtime Query Constraints</a></h4>
<div class="paragraph">
<p>Also, you can build upon the query builder to filter the results from the related models.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const user = yield User
  .with('profile', 'friends')
  .scope('profile', (builder) =&gt; {
    builder.where('is_active', true)
  }) <i class="conum" data-value="1"></i><b>(1)</b>
  .scope('friends', (builder) =&gt; {
    builder.orderBy('rank', 'desc')
  })
  .fetch()</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>scope</code> method gives you the access to the query builder of the related model which means you can add <code>where</code> clause to filter the results.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lazy_eager_loading"><a class="anchor" href="#_lazy_eager_loading"></a><a class="link" href="#_lazy_eager_loading">Lazy Eager Loading</a></h3>
<div class="paragraph">
<p>Lazy eager loading is a combination of <a href="#_lazy_loading">Lazy loading</a> and <a href="#_eager_loading">Eager Loading</a> instead of preloading all the relationships, you fetch the parent model instance and then eager load all related models.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const user = yield User.find(1)
yield user.related('profile', 'friends').load()

console.log(user.toJSON())</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Output</div>
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">[
  {
    id: 1,
    username: 'joe',
    email: '...',
    profile: {
      id: 4,
      avatar: '...'
    }
  }
]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_filtering_records"><a class="anchor" href="#_filtering_records"></a><a class="link" href="#_filtering_records">Filtering Records</a></h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Supported by adonis-lucid 3.0.13 or greater
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A quite common use case is to filter top-level results based upon some conditions on a relationship. For example:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Display all users who have contributed at least one post.</p>
</li>
<li>
<p>Fetch all cars with 2 or more owners in a lifetime.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Ideally, it requires some complex joins, but Lucid makes it so easier for you.</p>
</div>
<div class="sect3">
<h4 id="_has_relation_expression_value"><a class="anchor" href="#_has_relation_expression_value"></a><a class="link" href="#_has_relation_expression_value">has(relation, [expression], [value])</a></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">class User extends Lucid {

  posts () {
    return this.hasMany('App/Model/Post')
  }

}

// filtering
const users = yield User.query().has('posts').fetch()

// two or more
const users = yield User.query().has('posts', '&gt;=', 2).fetch()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_wherehas_relation_callback_expression_value"><a class="anchor" href="#_wherehas_relation_callback_expression_value"></a><a class="link" href="#_wherehas_relation_callback_expression_value">whereHas(relation, callback, [expression], [value])</a></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const users = yield User.query().whereHas('posts', (builder) =&gt; {
  builder.where('is_published', true)
}).fetch()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, you can make use of <code>doesntHave</code> and <code>whereDoesntHave</code> methods, which are opposite of the above ones.</p>
</div>
</div>
<div class="sect3">
<h4 id="_doesnthave_relation"><a class="anchor" href="#_doesnthave_relation"></a><a class="link" href="#_doesnthave_relation">doesntHave(relation)</a></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const users = yield User.query().doesntHave('friends').fetch()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_wheredoesnthave_relation_callback"><a class="anchor" href="#_wheredoesnthave_relation_callback"></a><a class="link" href="#_wheredoesnthave_relation_callback">whereDoesntHave(relation, callback)</a></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const users = yield User.query().whereDoesntHave('friends', (builder) =&gt; {
  builder.where('is_verified', false)
}).fetch()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_counting_related_models"><a class="anchor" href="#_counting_related_models"></a><a class="link" href="#_counting_related_models">Counting Related Models</a></h3>
<div class="paragraph">
<p>Getting counts of relationships is commonly used by web applications. For example: <strong>Fetching comments count for every post</strong>.</p>
</div>
<div class="sect3">
<h4 id="_withcount_relation"><a class="anchor" href="#_withcount_relation"></a><a class="link" href="#_withcount_relation">withCount(relation)</a></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">class Post extends Lucid {

  comments () {
    this.hasMany('App/Model/Comment')
  }

}

// fetching counts
const posts = yield Posts.query().withCount('comments').fetch()

console.log(posts.first().comments_count)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_insert_updates_deletes"><a class="anchor" href="#_insert_updates_deletes"></a><a class="link" href="#_insert_updates_deletes">Insert, Updates &amp; Deletes</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Relationships can also be <strong>created</strong>, <strong>updated</strong> and <strong>deleted</strong> with the same ease as fetching them. Whereas each relationship type has slightly different methods to persist related data.</p>
</div>
<div class="sect3">
<h4 id="_save_modelinstance_pivotvalues"><a class="anchor" href="#_save_modelinstance_pivotvalues"></a><a class="link" href="#_save_modelinstance_pivotvalues">save(modelInstance, [pivotValues])</a></h4>
<div class="paragraph">
<p>The <code>save</code> method can be used to create/update related model instance. It works with following relations.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p><code>pivotValues</code> are only supported by <strong>belongsToMany</strong> relationship. Checkout <a href="#_attach_rows_pivotvalues">attach</a> method documentation on how pivotValues are defined.</p>
</dd>
</dl>
</div>
<div class="olist support-list">
<ol class="support-list">
<li>
<p>hasOne</p>
</li>
<li>
<p>hasMany</p>
</li>
<li>
<p>belongsToMany</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const user = yield User.find(1)

const profile = new Profile()
profile.name = '@cybernox'
profile.avatar =  '...'

yield user.profile().save(profile)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_create_values_pivotvalues"><a class="anchor" href="#_create_values_pivotvalues"></a><a class="link" href="#_create_values_pivotvalues">create(values, [pivotValues])</a></h4>
<div class="paragraph">
<p>The <code>create</code> method is almost similar to the <code>save</code> method whereas you pass an arbitrary object instead of passing a model instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const user = yield User.find(1)

yield user
  .profile()
  .create({name: '@cybernox', avatar: '...'})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_savemany_arrayofinstances"><a class="anchor" href="#_savemany_arrayofinstances"></a><a class="link" href="#_savemany_arrayofinstances">saveMany(arrayOfInstances)</a></h4>
<div class="paragraph">
<p>Save multiple related records for a given model instance. <code>saveMany</code> works with following relation types.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>hasMany</p>
</li>
<li>
<p>belongsToMany</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const user = yield User.find(1)

const profile = new Profile({name: '@cybernox'})
const anotherProfile = new Profile({name: '@jgwhite'})

yield user.profile.saveMany([profile, anotherProfile])</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_createmany_arrayofvalues"><a class="anchor" href="#_createmany_arrayofvalues"></a><a class="link" href="#_createmany_arrayofvalues">createMany(arrayOfValues)</a></h4>
<div class="paragraph">
<p>The <code>createMany</code> method will also create multiple records whereas you pass an array of objects instead of model instances.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const user = yield User.find(1)
const profiles = yield user
  .profile()
  .createMany([{name: '@cybernox'}, {name: 'jgwhite'}])</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_attach_rows_pivotvalues"><a class="anchor" href="#_attach_rows_pivotvalues"></a><a class="link" href="#_attach_rows_pivotvalues">attach(rows, [pivotValues])</a></h4>
<div class="paragraph">
<p>The <code>attach</code> method only works with <strong>belongsToMany</strong> relationship. You attach existing records to form a relationship.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const student = yield Student.find(1)
const coursesIds = yield Courses.ids()

yield Student.courses().attach(coursesIds)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Optionally, you can pass an object to populate fields inside the <strong>pivotTable</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">yield Student.courses().attach(coursesIds, {enrollment_confirmed: false})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or you can also define different pivotValues for each related row.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const mathsId = yield Courses
  .query()
  .where('name', 'Maths')
  .pluckId()

const englishId = yield Courses
  .query()
  .where('name', 'English')
  .pluckId()

const enrollment = {}
enrollment[mathsId] = {enrollment_confirmed: true}
enrollment[englishId] = {enrollment_confirmed: false}

yield Student.courses().attach(enrollment)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_detach_rows"><a class="anchor" href="#_detach_rows"></a><a class="link" href="#_detach_rows">detach(rows)</a></h4>
<div class="paragraph">
<p>The <code>detach</code> method is the opposite of the <a href="#_attach_rows_pivot_values">attach</a> and will remove the relationships from pivotTable.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>detach</code> method does not remove the rows from the related model. It just removes the relationship from the pivot table.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const student = yield Student.find(1)
const coursesIds = yield Courses.ids()

yield Student.courses().detach(coursesIds)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sync_rows_pivotvalues"><a class="anchor" href="#_sync_rows_pivotvalues"></a><a class="link" href="#_sync_rows_pivotvalues">sync(rows, [pivotValues])</a></h4>
<div class="paragraph">
<p>The <code>sync</code> will remove all existing relations and will only add given relations. Think of it as calling <a href="#_detach_rows">detach</a> and <a href="#_attach_rows_pivot_values">attach</a> together.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can also pass <strong>pivotValues</strong> to the sync method similar to the attach method.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const student = yield Student.find(1)
const coursesIds = yield Courses.ids()

yield Student.courses().sync(coursesIds)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_updatepivot_values_relatedmodelid"><a class="anchor" href="#_updatepivot_values_relatedmodelid"></a><a class="link" href="#_updatepivot_values_relatedmodelid">updatePivot(values, [relatedModelId])</a></h4>
<div class="paragraph">
<p>In order to update the values inside the pivot table you can make use of <code>updatePivot</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const student = yield Student.find(1)
Student.courses().updatePivot({marks: 90})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const student = yield Student.find(1)
const maths = yield Course.where('name', 'Maths').first()
Student.courses().updatePivot({marks: 90}, maths.id)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_withpivot_keys"><a class="anchor" href="#_withpivot_keys"></a><a class="link" href="#_withpivot_keys">withPivot(keys)</a></h4>
<div class="paragraph">
<p>When fetching records for <strong>belongsToMany</strong> lucid will not select any rows from the pivot table. In order to fetch additional fields you can make use of <code>withPivot</code> method.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Pivot table fields will be prefixed with <code>_pivot_</code>. In below example the marks will be returned as <code>_pivot_marks</code>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">'use strict'

class Student extends Lucid {

  courses () {
    return this.belongsToMany('App/Model/Course').withPivot('marks')
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also you can define fields when running the select query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const student = yield Student.find(1)
const courses = yield student.courses().withPivot('marks').fetch()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_associate_modelinstance"><a class="anchor" href="#_associate_modelinstance"></a><a class="link" href="#_associate_modelinstance">associate(modelInstance)</a></h4>
<div class="paragraph">
<p>The <code>associate</code> method is used with <strong>belongsTo</strong> relationship to associate an existing database row.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const user = yield User.find(1)
const profile = new Profile()
profile.name = '@cybernox'

profile.user().associate(user)
yield profile.save()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dissociate"><a class="anchor" href="#_dissociate"></a><a class="link" href="#_dissociate">dissociate</a></h4>
<div class="paragraph">
<p>The <code>dissociate</code> method is the opposite of <a href="#_associate_model_instance">associate</a> and will remove the existing relationship</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight line-numbers"><code class="language-javascript" data-lang="javascript">const profile = yield Profile.find(1)

profile.user().dissociate()
yield profile.save()</code></pre>
</div>
</div>
</div>
</div>
</div>